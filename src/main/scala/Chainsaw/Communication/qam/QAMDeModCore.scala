package Chainsaw.Communication.qam

import Chainsaw._
import spinal.core._
import spinal.lib._

import scala.collection.mutable.ArrayBuffer

/** Qamdemod module for QAM2 <-> QAM256, using the constellations which are the same as Matlab
 *
 * @param symbolType    to define the QFormat of symbols in
 * @param bitsAllocated to define the modulation mode, 1 -> QAM2, 2 -> QAM4, ...
 */
case class QAMDeModCore(symbolType: HardType[ComplexNumber], bitsAllocated: Int) extends Component {

  val dataIn = slave Flow symbolType
  val dataOut = master Flow Bits(bitsAllocated bits)

  val maxExp = dataIn.payload.real.maxExp // in fact, this should be 1
  val minExp = dataIn.payload.real.minExp

  val thresholds = (i: Int) => SF(i / Refs.getQAMRms(bitsAllocated), maxExp exp, minExp exp)
  val abs = (value: SFix) => Mux(value.raw.msb, -value, value)
  val isPositive = (value: SFix) => ~value.raw.msb

  // generated by "fold"
  def dets(value: SFix, times: Int) = {
    val rets = ArrayBuffer[SFix]()
    (0 until times).foreach { i =>
      if (i == 0) rets += value
      else rets += (abs(rets.last) - thresholds(1 << (times - i)))
    }
    rets
  }

  val ret = bitsAllocated match {
    case _ =>
      val realDets = dets(dataIn.payload.real, (bitsAllocated + 1) / 2)
      val imagDets = dets(dataIn.payload.imag, bitsAllocated / 2)
      ((isPositive(realDets.head) +: realDets.tail.map(sf => ~isPositive(sf))) ++ imagDets.map(sf => ~isPositive(sf))).reverse.asBits()
  }

  dataOut.payload := RegNext(ret)
  dataOut.valid := RegNext(dataIn.valid, init = False)
}
