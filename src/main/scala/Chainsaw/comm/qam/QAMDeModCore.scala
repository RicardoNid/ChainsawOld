package Chainsaw.comm.qam

import Chainsaw._
import spinal.core._
import spinal.lib._

import scala.collection.mutable.ArrayBuffer

/** Qamdemod module for QAM2 <-> QAM256, using the constellations which are the same as Matlab
  *
  * @param symbolType
  *   to define the QFormat of symbols in
  * @param bitsAllocated
  *   to define the modulation mode, 1 -> QAM2, 2 -> QAM4, ...
  */
case class QAMDeModCore(symbolType: HardType[ComplexNumber], bitsAllocated: Int, factor: Double = 1.0) extends Component {

  require(bitsAllocated > 0 && bitsAllocated <= 8)
  if (bitsAllocated == 5 || bitsAllocated == 7) logger.warn(s"QAM32/QAM128 are specially, which can't be fully implemented by using threshold values")

  val dataIn  = slave Flow symbolType
  val dataOut = master Flow Bits(bitsAllocated bits)
  dataIn.valid.allowPruning()
  dataOut.valid.allowPruning()

  val maxExp = dataIn.payload.real.maxExp // in fact, this should be 1
  val minExp = dataIn.payload.real.minExp

  val thresholds = (i: Int) => SF(i / Refs.getQAMRms(bitsAllocated) * factor, maxExp exp, minExp exp) // TODO: get threshold from a RAM
  val abs        = (value: SFix) => Mux(value.raw.msb, -value, value)
  val isPositive = (value: SFix) => ~value.raw.msb

  // generated by "fold"
  def dets(value: SFix, times: Int) = {
    val rets = ArrayBuffer[SFix]()
    (0 until times).foreach { i =>
      if (i == 0) rets += value
      else rets += (abs(rets.last) - thresholds(1 << (times - i)))
    }
    rets
  }

  val realLt     = (value: Int) => ~isPositive(abs(dataIn.payload.real) - thresholds(value))
  val imagLt     = (value: Int) => ~isPositive(abs(dataIn.payload.imag) - thresholds(value))
  val realLtImag = abs(dataIn.payload.real) < abs(dataIn.payload.imag)

  val ret = bitsAllocated match {
    case 5 =>
      val bit0 = isPositive(dataIn.payload.real)
      val bit3 = ~isPositive(dataIn.payload.imag)

      val bit1 = realLt(4) && imagLt(4)
      val bit2 = (!realLt(2) && imagLt(4)) || (!realLt(4) && !imagLt(4) && !realLtImag)
      val bit4 = imagLt(2) || (realLt(2) && !imagLt(4))
      Seq(bit0, bit1, bit2, bit3, bit4).reverse.asBits()

    case 7 =>
      val bit0 = isPositive(dataIn.payload.real) // diff = 64
      val bit4 = ~isPositive(dataIn.payload.imag) // diff = 4

      val bit1 = realLt(8) && imagLt(8) // diff = 32
      val bit2 = (!realLt(4) && imagLt(8)) || (!realLt(8) && !imagLt(8) && !realLtImag) // diff = 16 // TODO: diag
      val bit3 = (!realLt(2) && realLt(6)) || (!realLt(10) && !realLtImag) // diff = 8 // TODO: the "tiny triangle"
      val bit5 = imagLt(4) || (realLt(4) && !imagLt(8)) // diff = 2
      val bit6 = (!imagLt(2) && imagLt(6)) || (!imagLt(10) && realLtImag) // diff = 1

      Seq(bit0, bit1, bit2, bit3, bit4, bit5, bit6).reverse.asBits()

    case _ =>
      val realDets = dets(dataIn.payload.real, (bitsAllocated + 1) / 2)
      val imagDets = dets(dataIn.payload.imag, bitsAllocated / 2)
      ((isPositive(realDets.head) +: realDets.tail.map(sf => ~isPositive(sf))) ++ imagDets.map(sf => ~isPositive(sf))).reverse.asBits()
  }

  dataOut.payload := RegNext(ret)
  dataOut.valid   := RegNext(dataIn.valid, init = False)
}

object QAMDeModCore {
  def main(args: Array[String]): Unit = {
    val reports = (1 to 8).map(i => VivadoSynth(QAMDeModCore(HardType(ComplexNumber(1, -14)), i)))
    println(reports.map(_.LUT).mkString(""))
    println(reports.map(_.FF).mkString(" "))
  }
}
