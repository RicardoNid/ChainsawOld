package xilinx

import org.apache.commons.io.FileUtils
import spinal.core._

import java.io.File
import scala.collection.mutable
import scala.sys.process._

/**
 */
class VivadoFlow[T <: Component](
                                  design: => T,
                                  taskType: VivadoTaskType,
                                  vivadoConfig: VivadoConfig,
                                  xilinxDevice: XilinxDevice,
                                  topModuleName: String = null,
                                  workspacePath: String = null,
                                  alterXdc: String = null,
                                  extraRtlSources: Seq[String] = null
                                ) {

  val isWindows = System.getProperty("os.name").toLowerCase().contains("win")

  /**
   * generate XDC constraints content for Vivado Flow
   *
   * priority: alter xdc > device xdc > xdc built from fmax
   *
   * @return XDC constraints
   */
  def buildXdc: String = {
    if (alterXdc != null) alterXdc
    else if (xilinxDevice.constraint != null) xilinxDevice.constraint
    else {
      val targetPeriod = xilinxDevice.fmax.toTime
      s"""create_clock -period ${(targetPeriod * 1e9) toBigDecimal} [get_ports clk]"""
    }
  }

  /**
   * generate tcl script content for Vivado Flow
   *
   * {{{the generated tcl script will consists of these commands:}}}
   * {{{    read_verilog -sv xxx.sv (or read_verilog, read_vhdl)}}}
   * {{{    read_xdc xxx.xdc}}}
   * {{{    synth_design -part xxx -top xxx}}}
   * {{{    opt_design (for implementation)}}}
   * {{{    place_design (for implementation)}}}
   * {{{    route_design (for implementation)}}}
   * {{{    write_bitstream -force xxx.bit (for implementation)}}}
   * {{{    report_utilization}}}
   * {{{    report_timing}}}
   * {{{    write_checkpoint xxx.dcp}}}
   *
   * @param dutRtlSources paths of rtl sources generated by dut
   * @return context of tcl script
   */
  def buildScript(dutRtlSources: mutable.LinkedHashSet[String]): String = {
    var script = ""

    def getReadCommand(sourcePath: String) = {
      if (sourcePath.endsWith(".sv")) s"read_verilog -sv $sourcePath \n"
      else if (sourcePath.endsWith(".v")) s"read_verilog $sourcePath \n"
      else if (sourcePath.endsWith(".vhdl") || sourcePath.endsWith(".vhd")) s"read_vhdl $sourcePath \n"
      else if (sourcePath.endsWith(".bin")) "\n" // TODO: how to add bin source?
      else throw new IllegalArgumentException(s"invalid RTL source path $sourcePath")
    }

    // read design sources
    // sources from dut
    dutRtlSources.map(_.replace(workspacePath + "/", "")).foreach(script += getReadCommand(_))
    // extra sources
    if (extraRtlSources != null) extraRtlSources.foreach(script += getReadCommand(_))

    // read constraint sources
    script += s"read_xdc doit.xdc\n"

    taskType match {

      case SYNTH =>
        script += s"synth_design -part ${xilinxDevice.part} -top ${topModuleName} -mode out_of_context\n"
        script += s"write_checkpoint -force ${topModuleName}_after_synth.dcp\n"
      case IMPL =>
        script += s"synth_design -part ${xilinxDevice.part} -top ${topModuleName} -mode out_of_context\n"
        script += s"write_checkpoint -force ${topModuleName}_after_synth.dcp\n"
        script += "opt_design\n"
        script += "place_design\n"
        script += s"write_checkpoint -force ${topModuleName}_after_place.dcp\n"
        script += "route_design\n"
        script += s"write_checkpoint -force ${topModuleName}_after_route.dcp\n"
      //        script += s"write_bitstream -force ${topModuleName}.bit\n"
    }
    // util & timing can't be reported before synthesis
    script += s"report_utilization\n"
    script += s"report_timing\n"
    script
  }

  /**
   * @return VivadoReport as an object
   */
  def doFlow() = {

    // prepare the workspace
    //    val workspacePathFile = new File(workspacePath)
    //    if (workspacePathFile.listFiles != null) {
    //      assert(force, "the workspace is not empty, to flush it anyway, using \"force = true\"")
    //      FileUtils.deleteDirectory(workspacePathFile)
    //    }
    //    workspacePathFile.mkdir()    // this may lead to bug

    Process(s"mkdir -p $workspacePath") ! // create directory in this way instead

    // generate sources from dut
    val spinalReport = SpinalConfig(targetDirectory = workspacePath).generateVerilog(design.setDefinitionName(topModuleName))

    FileUtils.write(new File(s"$workspacePath/doit.tcl"), buildScript(spinalReport.rtlSourcesPaths))
    FileUtils.write(new File(s"$workspacePath/doit.xdc"), buildXdc)

    doCmd(s"${vivadoConfig.vivadoPath}/vivado -stack 2000 -nojournal -log doit.log -mode batch -source doit.tcl", workspacePath)

    new VivadoReport(workspacePath, xilinxDevice.family, xilinxDevice.fmax)
  }


  /**
   * execute cmd command on host at given path
   *
   * @param command cmd command
   * @param path    workspace
   */
  private def doCmd(command: String, path: String): Unit = { // do cmd at the workSpace
    println(command)
    if (isWindows)
      Process("cmd /C " + command, new java.io.File(path)) !
    else
      Process(command, new java.io.File(path)) !
  }

  // utils for flow
}

// TODO: modify the API, name and path should be passed to the Flow, so the user can use Config and Task from the recommendation
object VivadoFlow {
  def apply[T <: Component](
                             design: => T, taskType: VivadoTaskType,
                             vivadoConfig: VivadoConfig = VivadoConfig(),
                             xilinxDevice: XilinxDevice = vu9p,
                             topModuleName: String = null, workspacePath: String = null, alterXdc: String = null, extraRtlSources: Seq[String] = null): VivadoFlow[T] =
    new VivadoFlow(design, taskType, vivadoConfig, xilinxDevice, topModuleName, workspacePath, alterXdc, extraRtlSources)
}