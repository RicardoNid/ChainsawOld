package FTN

import com.mathworks.engine.MatlabEngine
import com.mathworks.matlab.types.Complex
import spinal.core._
import spinal.core.sim._
import spinal.lib._
import spinal.sim._
import spinal.lib.fsm._
import Chainsaw._
import Chainsaw.Real
import breeze.numerics.abs

class FFT(input: Vec[Real]) extends DSPArea[Vec[Real], Array[Complex], Array[Complex]] {
  // TODO: implement
  override def timing: TimingInfo = TimingInfo(1, 1, 1, 1)

  override def referenceModel(testCase: Array[Complex]): Array[Complex] = {
    val eng = MatlabEngine.startMatlab
    val ret = eng.feval("fft", testCase).asInstanceOf[Array[Complex]]
    eng.close()
    ret
  }

  val N = input.length

  def coeffW(k: Int, n: Int) = {
    import breeze.numerics._
    import breeze.numerics.constants.Pi
    val exp = (-2) * Pi * k * n / N
    val real = cos(exp)
    val imag = sin(exp)
    new Complex(real, imag)
  }


  // TODO: Implement
  override def implicitValue: Vec[Real] = {
    val ret = if (isPow2(N)) { // using butterfly
      val layer = log2Up(N)

      def build(input: Vec[Real], layerRemained: Int): Vec[Real] = {
        require(layerRemained >= 1)

        layerRemained match {
          case 1 => Vec(input(0) + input(2), input(1) + input(3), input(0) - input(2), input(1) - input(3))
          case _ => {
            val half = input.length / 2
            val upper = input.take(half)
            val lower = input.takeRight(half)
            val midUpper = upper.zip(lower).map { case (up, low) => up + low }
            val midLower = upper.zip(lower).map { case (up, low) => up - low }
            val mid = midUpper ++ midLower
            // TODO:
            val ret = mid.map(_ * 1.0)
            build(Vec(ret), layerRemained - 1)
          }
        }
      }

      build(input, layer)
    }
    else {
      // TODO
      throw new IllegalArgumentException("not implemented yet")
    }
    RegNext(ret)
  }
}

class FFTDUT extends DSPDUTTiming[Vec[Real], Vec[Real]] {
  override val input: Vec[Real] = in Vec(RealWithError(-1.5, 2.5, -15 exp), 4 * 2)
  val fft = new FFT(input)
  override val output: Vec[Real] = out(fft.implicitValue)
  override val timing: TimingInfo = fft.timing
}

class FFTSim extends FFTDUT with DSPSimTiming[Vec[Real], Vec[Real], Array[Complex], Array[Complex]] {
  override def poke(testCase: Array[Complex], input: Vec[Real]): Unit = {
    testCase.indices.foreach { i =>
      input(2 * i) #= testCase(i).real
      input(2 * i + 1) #= testCase(i).imag
    }
  }

  override def peek(output: Vec[Real]): Array[Complex] =
    (0 until output.length / 2).map(i => new Complex(output(2 * i).toDouble, output(2 * i + 1).toDouble)).toArray


  /** The function that takes the testCase and return the ground truth
   *
   * @param testCase testCase
   * @return testResult
   */
  override def referenceModel(testCase: Array[Complex]): Array[Complex] = fft.referenceModel(testCase)

  /** Define the conditions by which you regard ref and dut as the same
   *
   * @param refResult - golden truth generated by the reference model
   * @param dutResult - output generated by DUT
   * @return
   */
  override def isValid(refResult: Array[Complex], dutResult: Array[Complex]): Boolean = {
    val refDoubles = refResult.flatMap(complex => Array(complex.real, complex.imag))
    val dutDoubles = dutResult.flatMap(complex => Array(complex.real, complex.imag))
    output.map(_.error).zip(refDoubles.zip(dutDoubles))
      .forall { case (err, pair) => abs(pair._1 - pair._2) <= err }
  }

  /** Message String to log when !isValid(refResult, dutResult)
   *
   * @param testCase  - testCase corresponding to the result
   * @param refResult - golden truth generated by the reference model
   * @param dutResult - output generated by DUT
   */
  override def messageWhenInvalid(testCase: Array[Complex], refResult: Array[Complex], dutResult: Array[Complex]): String = {
    val refDoubles = refResult.flatMap(complex => Array(complex.real, complex.imag))
    val dutDoubles = dutResult.flatMap(complex => Array(complex.real, complex.imag))
    s"golden: ${refDoubles.mkString(" ")}, yours: ${dutDoubles.mkString(" ")}"
  }

  override def messageWhenValid(testCase: Array[Complex], refResult: Array[Complex], dutResult: Array[Complex]): String =
    messageWhenInvalid(testCase, refResult, dutResult)
}

object FFTSim {
  def main(args: Array[String]): Unit = {
    SimConfig.withWave.compile(new FFTSim).doSim { dut =>
      dut.sim()
      dut.insertTestCase((0 until 4).map(i => new Complex(i, i)).toArray)
      dut.insertTestCase((0 until 4).map(i => new Complex(i, i)).toArray)
      dut.simDone()
    }
  }
}


