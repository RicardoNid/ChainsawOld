package FTN

import Chainsaw._
import breeze.numerics.{abs, pow}
import com.mathworks.matlab.types.Complex
import spinal.core._
import spinal.core.sim._

class FFT(input: Vec[Real], inverse: Boolean = false) extends DSPArea[Vec[Real], Array[Complex], Array[Complex]] {
  // TODO: implement
  override def timing: TimingInfo = TimingInfo(1, 1, 1, 1)

  override def referenceModel(testCase: Array[Complex]): Array[Complex] = {
    val functionName = if(inverse) "ifft" else "fft"
    eng.feval(functionName, testCase).asInstanceOf[Array[Complex]]
  }

  val N = input.length / 2

  val inputComplexes = (0 until N).map(i => ComplexReal(input(2 * i), input(2 * i + 1)))

  def coeffW(kn: Int) = {
    import breeze.numerics._
    import breeze.numerics.constants.Pi
    printlnYellow(s"coeffW($kn) being invoked")
    val exp = (-2) * Pi * kn / N
    val real = cos(exp)
    val imag = sin(exp)
    printlnYellow(s"real: $real, imag: $imag")
    val realReal = QFormatReal(SQ(16, 15))
    println(s"error from coeff ${realReal.error}")
    realReal := real
    val imagReal = QFormatReal(SQ(16, 15))
    println(s"error from coeff ${imagReal.error}")
    imagReal := imag
    ComplexReal(realReal, imagReal)
  }

  // TODO: Implement
  override def implicitValue: Vec[Real] = {
    val ret = if (isPow2(N)) { // using butterfly
      val layer = log2Up(N)

      def indexReverse(index: Int): Int = index
        .toBinaryString.reverse.padTo(layer, '0').reverse
        .zipWithIndex.map { case (c, i) => c.asDigit * (1 << i) }.sum

      def build(input: Seq[ComplexReal], layerRemained: Int): Seq[ComplexReal] = {
        require(layerRemained >= 1)

        printlnGreen(s"${input.length / 2}")
        layerRemained match {
          case 1 => Seq(input(0) + input(1), (input(0) - input(1)) * coeffW(0))
          case _ => {
            val half = input.length / 2
            val upper = input.take(half)
            val lower = input.takeRight(half)
            val midUpper = upper.zip(lower).map { case (up, low) => up + low }
            val midLower = upper.zip(lower).map { case (up, low) => up - low }
            printlnRed(s"lower length ${midLower.length}")
            val midLowerMultiplied = midLower.zipWithIndex.map { case (complexReal, i) =>
              val kn = i * (1 << (layer - layerRemained))
              complexReal * (if (inverse) coeffW(-kn) else coeffW(kn))
            }
            val ret = midUpper ++ midLowerMultiplied
            build(ret.take(half), layerRemained - 1) ++ build(ret.takeRight(half), layerRemained - 1)
          }
        }
      }

      printlnRed(s"N is $N")
      val disorded = build(inputComplexes, layer)
      (0 until N).map(i => disorded(indexReverse(i)))
        .flatMap(complexReal => Vec(complexReal.real, complexReal.imag))
        .map(real => if (inverse) real << layer else real)
    }
    else {
      // TODO
      throw new IllegalArgumentException("not implemented yet")
    }

    println(s"final errors ${ret.map(_.error).mkString(" ")}")
    RegNext(Vec(ret))
  }
}

class FFTDUT(N: Int) extends DSPDUTTiming[Vec[Real], Vec[Real]] {
  override val input: Vec[Real] = in Vec(RealWithError(-1.5, 2.5, -15 exp), N * 2)
  val fft = new FFT(input)
  override val output: Vec[Real] = out(fft.implicitValue)
  override val timing: TimingInfo = fft.timing
}

class FFTSim(N: Int) extends FFTDUT(N) with DSPSimTiming[Vec[Real], Vec[Real], Array[Complex], Array[Complex]] {
  override def poke(testCase: Array[Complex], input: Vec[Real]): Unit = {
    testCase.indices.foreach { i =>
      input(2 * i) #= testCase(i).real
      input(2 * i + 1) #= testCase(i).imag
    }
  }

  override def peek(output: Vec[Real]): Array[Complex] =
    (0 until output.length / 2).map(i => new Complex(output(2 * i).toDouble, output(2 * i + 1).toDouble)).toArray


  /** The function that takes the testCase and return the ground truth
   *
   * @param testCase testCase
   * @return testResult
   */
  override def referenceModel(testCase: Array[Complex]): Array[Complex] = fft.referenceModel(testCase)

  /** Define the conditions by which you regard ref and dut as the same
   *
   * @param refResult - golden truth generated by the reference model
   * @param dutResult - output generated by DUT
   * @return
   */
  override def isValid(refResult: Array[Complex], dutResult: Array[Complex]): Boolean = {
    val refDoubles = refResult.flatMap(complex => Array(complex.real, complex.imag))
    val dutDoubles = dutResult.flatMap(complex => Array(complex.real, complex.imag))
    output.map(_.error).zip(refDoubles.zip(dutDoubles))
      .forall { case (err, pair) => abs(pair._1 - pair._2) <= pow(2, 0) }
  }

  /** Message String to log when !isValid(refResult, dutResult)
   *
   * @param testCase  - testCase corresponding to the result
   * @param refResult - golden truth generated by the reference model
   * @param dutResult - output generated by DUT
   */
  override def messageWhenInvalid(testCase: Array[Complex], refResult: Array[Complex], dutResult: Array[Complex]): String = {
    val refDoubles = refResult.flatMap(complex => Array(complex.real, complex.imag))
    val dutDoubles = dutResult.flatMap(complex => Array(complex.real, complex.imag))
    s"golden: ${refDoubles.mkString(" ")}\nyours : ${dutDoubles.mkString(" ")}"
  }

  override def messageWhenValid(testCase: Array[Complex], refResult: Array[Complex], dutResult: Array[Complex]): String =
    messageWhenInvalid(testCase, refResult, dutResult)
}

object FFTSim {
  def main(args: Array[String]): Unit = {
    ChainsawExpLowerBound = -16
    SimConfig.withWave.compile(new FFTSim(512)).doSim { dut =>
      dut.sim()
      (0 until 20).foreach(_ => dut.insertTestCase((0 until 512).map(_ => new Complex(DSPRand.nextDouble(), DSPRand.nextDouble())).toArray))
      dut.simDone()
    }
    eng.close()
  }
}


